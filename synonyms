'''Semantic Similarity

Author: Aahan Madhok and Yahya Ahmed.
'''

import math
import re


def norm(vec):
    '''Return the norm of a vector stored as a dictionary, as
    described in the handout for Project 3.
    '''

    sum_of_squares = 0.0
    for x in vec:
        sum_of_squares += vec[x] * vec[x]

    return math.sqrt(sum_of_squares)


def cosine_similarity(vec1, vec2):
    sum_of_squares_1 = 0.0
    sum_of_squares_2 = 0.0
    dot_prod = 0.0

    for x in vec1:
        sum_of_squares_1 += vec1[x] * vec1[x]
    sqrt_1 = math.sqrt(sum_of_squares_1)

    for y in vec2:
        sum_of_squares_2 += vec2[y] * vec2[y]
    sqrt_2 = math.sqrt(sum_of_squares_2)

    for key1, value1 in vec1.items():
        if key1 in vec2:
            value2 = vec2[key1]
            dot_prod += value1 * value2

    return dot_prod / (sqrt_1 * sqrt_2)


def build_semantic_descriptors(sentences):
    semantic_descriptors = {}

    for sentence in sentences:
        unique_words = set(sentence)

        for key_word in unique_words:
            if key_word not in semantic_descriptors:
                semantic_descriptors[key_word] = {}

            for other_word in unique_words:
                if other_word != key_word:
                    semantic_descriptors[key_word][other_word] = semantic_descriptors[key_word].get(other_word, 0) + 1

    return semantic_descriptors



# def build_semantic_descriptors_from_files(filenames):
#     for i in range(len(filenames)):
#         open(filenames[i], "r", encoding="latin1").read().split()


def build_semantic_descriptors_from_files(filenames):
    semantic_descriptors = {}

    for filename in filenames:
        with open(filename, "r", encoding="latin1") as file:
            content = file.read()
            sentences = re.split(r"[.!?]", content)  # Split content into sentences
            sentences = [sentence.strip() for sentence in sentences if sentence.strip()]  #  list comprehension in Python. # for sentence in sentences: This iterates over each element (sentence) in the sentences list.
# if sentence.strip(): This checks if the stripped version of the current sentence is not an empty string. The strip() method removes leading and trailing whitespaces from a string. So, sentence.strip() checks if the sentence is not just whitespace.
# Putting it all together, the list comprehension creates a new list (sentences) that contains only those sentences from the original list (sentences) where the stripped version of the sentence is not an empty string. In other words, it filters out empty sentences.
#
# This is often done to handle cases where there might be empty sentences in the text, and you want to exclude them from further processing. The resulting sentences list will only contain non-empty sentences.

            for sentence in sentences:
                words = sentence.split()

                # Convert all words to lowercase
                words = [word.lower() for word in words]

                for i, key_word in enumerate(words):
                    if key_word not in semantic_descriptors:
                        semantic_descriptors[key_word] = {}

                    # Update semantic descriptor based on context words in the same sentence
                    other_words = words[:i] + words[i+1:]
                    other_words = [other_word.lower() for other_word in other_words]
                    for other_word in other_words:
                        semantic_descriptors[key_word][other_word] = semantic_descriptors[key_word].get(other_word, 0) + 1

    return semantic_descriptors



def most_similar_word(word, choices, semantic_descriptors, similarity_fn):
     word_descriptor = semantic_descriptors.get(word, {})
     best_choice = None
     max_similarity = -1

     for choice in choices:
         choice_descriptor = semantic_descriptors.get(choice, {})
         similarity = similarity_fn(word_descriptor, choice_descriptor)

         if similarity > max_similarity or (similarity == max_similarity and choice < best_choice):
             best_choice = choice
             max_similarity = similarity

     return best_choice


def run_similarity_test(filename, semantic_descriptors, similarity_fn):
    pass
